Disassembly Listing for Rechenleistung
Generated From:
C:/Temp/Rechenleistung/Rechenleistung.X/dist/default/debug/Rechenleistung.X.debug.elf
28.03.2017 17:05:18

---  C:/Temp/Rechenleistung/Rechenleistung.X/primzahlen.c  ----------------------------------------------
1:                 /** 
2:                  * @file   HelloWorld2.c
3:                  * @author JS
4:                  *
5:                  * @date 26.08.2015, 12:43
6:                  * 
7:                  * @brief Getting started with a simple program (blinking LED)
8:                  */
9:                 
10:                
11:                
12:                // Check for Project Settings
13:                #ifndef __dsPIC33EP512MU810__
14:                    #error "Wrong Controller"
15:                #endif
16:                
17:                /* ***********************
18:                 * Includes
19:                 * ***********************
20:                 */
21:                
22:                
23:                #include <xc.h>         //Include appropriate controller specific headers
24:                #include <stdint.h>     //Standard typedefs
25:                #include <stdlib.h>
26:                #include<math.h>
27:                
28:                
29:                /* ***********************
30:                 * Configuration Bits
31:                 * ***********************
32:                 */
33:                
34:                /*
35:                 * Oscillator Configuration
36:                 *  (XC16 Compiler User's Guide, P. 109,
37:                 *  33EP512MU810.html, p33EP512MU810.h, )
38:                 * Alternative: #pragma directives
39:                 */
40:                
41:                // old
42:                //_FOSCSEL(FNOSC_FRC); //Initial Oscillator:  Internal Fast RC
43:                //_FOSC(POSCMD_NONE);  //Primary Oscillator disabled (quartz not used)
44:                
45:                // old
46:                _FOSCSEL(FNOSC_PRIPLL); //Initial Oscillator: Primary Oscillator (XT, HS, EC) with PLL
47:                _FOSC(POSCMD_HS);  //HS Crystal Oscillator Mode
48:                
49:                
50:                
51:                /* ***********************
52:                 * Defines
53:                 * ***********************
54:                 */
55:                
56:                /* Substitute for stdlib.h */
57:                #define	EXIT_SUCCESS	0
58:                #define	EXIT_FAILURE	1
59:                
60:                /* Hardware  */
61:                #define _LED200 LATBbits.LATB8
62:                
63:                /* ***********************
64:                 * Prototypes
65:                 * ***********************
66:                 */
67:                
68:                void delay_ms(uint16_t u16milliseconds);
69:                uint8_t isPrim(uint32_t ui32Number);
70:                
71:                /* ***********************
72:                 * Definitions
73:                 * ***********************
74:                 */
75:                
76:                /** 
77:                 * @brief Provides u16milliseconds delay
78:                 * @param u16milliseconds Delay in milliseconds
79:                 * @details u16milliseconds=0 causes 65536 ms delay
80:                 * @pre 7.37 MHz (Internal Fast RC), e. g.: <br>
81:                 * _FOSCSEL(FNOSC_FRC); //Initial Oscillator:  Internal Fast RC <br>
82:                 * _FOSC(POSCMD_NONE);  //Primary Oscillator disabled (quartz not used) <br>
83:                 * s. 7.37 MHz DS70216C-page 39-19 <br>
84:                 * @attention Code has to be changed if a different oscillator frequency is used.
85:                 */
86:                void delay_ms(uint16_t u16milliseconds){
000600  FA0004     LNK #0x4
000602  980710     MOV W0, [W14+2]
87:                    uint16_t ui16_i=0;
000604  EB0000     CLR W0
000606  780F00     MOV W0, [W14]
88:                    while(u16milliseconds){
000608  37000E     BRA 0x626
000626  90001E     MOV [W14+2], W0
000628  E00000     CP0 W0
00062A  3AFFEF     BRA NZ, 0x60A
89:                        for (ui16_i=0;ui16_i<331;ui16_i++){    //1 ms delay loop
00060A  EB0000     CLR W0
00060C  780F00     MOV W0, [W14]
00060E  370004     BRA 0x618
000616  E80F1E     INC [W14], [W14]
000618  2014A0     MOV #0x14A, W0
00061A  78009E     MOV [W14], W1
00061C  508F80     SUB W1, W0, [W15]
00061E  36FFF8     BRA LEU, 0x610
90:                            __asm__ volatile("nop \n\t"
000610  000000     NOP
000612  000000     NOP
000614  000000     NOP
91:                                             "nop \n\t"
92:                                             "nop \n\t");
93:                        }//for
94:                        u16milliseconds--;
000620  90001E     MOV [W14+2], W0
000622  E90000     DEC W0, W0
000624  980710     MOV W0, [W14+2]
95:                    }//while
96:                
97:                }
00062C  FA8000     ULNK
00062E  060000     RETURN
98:                /* ***********************
99:                 * Main
100:                * ***********************
101:                */
102:               
103:               
104:               /**
105:                * Hello World (Blinking LED)
106:                * @brief Toggles LED200 with 1 Hz, 1:1 duty cycle
107:                */
108:               
109:               int main() {    //scope_25 47,8ms
000630  FA0008     LNK #0x8
110:               
111:                   PLLFBD = 418;
000632  201A20     MOV #0x1A2, W0
000634  883A30     MOV W0, PLLFBD
112:                   CLKDIVbits.PLLPOST = 2;
000636  803A21     MOV CLKDIV, W1
000638  2FF3F0     MOV #0xFF3F, W0
00063A  608000     AND W1, W0, W0
00063C  A07000     BSET W0, #7
00063E  883A20     MOV W0, CLKDIV
113:                   CLKDIVbits.PLLPRE = 2;
000640  803A21     MOV CLKDIV, W1
000642  2FFE00     MOV #0xFFE0, W0
000644  608000     AND W1, W0, W0
000646  A01000     BSET W0, #1
000648  883A20     MOV W0, CLKDIV
114:                   
115:                   /* Port Configurations */
116:                   // DS70616G-page 209
117:                   // ODCB (open drain config) unimplemented (DS70616G, Table 4-56)
118:                   ANSELBbits.ANSB8=0;     //Digital I/O
00064A  A90E1F     BCLR 0xE1F, #0
119:                   CNENBbits.CNIEB8=0;     //Disable change notification interrupt
00064C  A90E19     BCLR 0xE19, #0
120:                   CNPUBbits.CNPUB8=0;     //Disable weak pullup
00064E  A90E1B     BCLR 0xE1B, #0
121:                   CNPDBbits.CNPDB8=0;     //Disable weak pulldown
000650  A90E1D     BCLR 0xE1D, #0
122:                   TRISBbits.TRISB8=0;     //Pin B8: Digital Output
000652  A90E11     BCLR 0xE11, #0
123:                   LATBbits.LATB8=0;       //Pin B8: Low
000654  A90E15     BCLR 0xE15, #0
124:                   _LED200 = 1;
000656  A80E15     BSET 0xE15, #0
125:                   //uint32_t    ui32Var1=2;
126:                   //uint32_t    ui32Var2=2;
127:                   //uint32_t    ui32Var3=2;
128:                   while (OSCCONbits.LOCK!= 1);
000658  000000     NOP
00065A  803A11     MOV OSCCON, W1
00065C  200200     MOV #0x20, W0
00065E  608000     AND W1, W0, W0
000660  E00000     CP0 W0
000662  32FFFB     BRA Z, 0x65A
129:                   /* Endless Loop */
130:                   
131:                   uint32_t ui32Number= 1000000;     //start value
000664  242400     MOV #0x4240, W0
000666  2000F1     MOV #0xF, W1
000668  BE8F00     MOV.D W0, [W14]
132:                   uint16_t ui8PrimeCounter=0;       //counts the number of calculated prime numbers
00066A  EB0000     CLR W0
00066C  980720     MOV W0, [W14+4]
133:                   const uint16_t ui8PrimMax=10;
00066E  2000A0     MOV #0xA, W0
000670  980730     MOV W0, [W14+6]
134:                   
135:                   while(1){
136:               
137:                   _LED200=1;      //hard on/off 28,5ns  scope_15
000672  A80E15     BSET 0xE15, #0
138:                       
139:                   ui32Number= 1000000;     //start value
000674  242400     MOV #0x4240, W0
000676  2000F1     MOV #0xF, W1
000678  BE8F00     MOV.D W0, [W14]
140:                   ui8PrimeCounter=0;       //counts the number of calculated prime numbers
00067A  EB0000     CLR W0
00067C  980720     MOV W0, [W14+4]
141:                   //ui8PrimMax=10;
142:               
143:                   for(; ui8PrimeCounter<ui8PrimMax; ui32Number++)
00067E  37000B     BRA 0x696
00068E  200012     MOV #0x1, W2
000690  200003     MOV #0x0, W3
000692  410F1E     ADD W2, [W14], [W14]
000694  49975E     ADDC W3, [++W14], [W14--]
000696  9000AE     MOV [W14+4], W1
000698  90003E     MOV [W14+6], W0
00069A  508F80     SUB W1, W0, [W15]
00069C  39FFF1     BRA NC, 0x680
144:                       if(isPrim(ui32Number)) //check if the number is prime
000680  BE001E     MOV.D [W14], W0
000682  070011     RCALL isPrim
000684  E00400     CP0.B W0
000686  320003     BRA Z, 0x68E
145:                       {
146:                           //printf("%d\t%d\n",ui8PrimeCounter,ui32Number);
147:                           ui8PrimeCounter++; //increase PrimeCounter, if the number is prime
000688  90002E     MOV [W14+4], W0
00068A  E80000     INC W0, W0
00068C  980720     MOV W0, [W14+4]
148:                       }
149:                       
150:                       _LED200=0; 
00069E  A90E15     BCLR 0xE15, #0
151:                       delay_ms(500);
0006A0  201F40     MOV #0x1F4, W0
0006A2  07FFAE     RCALL delay_ms
152:                      
153:                   }//while
0006A4  37FFE6     BRA 0x672
154:                   
155:                   return (EXIT_SUCCESS);  //never reached
156:               } //main()
157:               
158:               uint8_t isPrim(uint32_t ui32Number){
0006A6  FA000C     LNK #0xC
0006A8  980740     MOV W0, [W14+8]
0006AA  980751     MOV W1, [W14+10]
159:               
160:                   if(ui32Number==0 || ui32Number==1)
0006AC  90004E     MOV [W14+8], W0
0006AE  9000DE     MOV [W14+10], W1
0006B0  500FE0     SUB W0, #0x0, [W15]
0006B2  588FE0     SUBB W1, #0x0, [W15]
0006B4  320007     BRA Z, 0x6C4
0006B6  90014E     MOV [W14+8], W2
0006B8  9001DE     MOV [W14+10], W3
0006BA  200010     MOV #0x1, W0
0006BC  200001     MOV #0x0, W1
0006BE  510F80     SUB W2, W0, [W15]
0006C0  598F81     SUBB W3, W1, [W15]
0006C2  3A0002     BRA NZ, 0x6C8
161:                       return 0;
0006C4  EB4000     CLR.B W0
0006C6  370041     BRA 0x74A
162:               
163:                   
164:                   if((ui32Number%2)==0)
0006C8  90014E     MOV [W14+8], W2
0006CA  9001DE     MOV [W14+10], W3
0006CC  200010     MOV #0x1, W0
0006CE  200001     MOV #0x0, W1
0006D0  780202     MOV W2, W4
0006D2  780103     MOV W3, W2
0006D4  780180     MOV W0, W3
0006D6  780001     MOV W1, W0
0006D8  620203     AND W4, W3, W4
0006DA  610000     AND W2, W0, W0
0006DC  EB0080     CLR W1
0006DE  DD00C0     SL W0, #0, W1
0006E0  200000     MOV #0x0, W0
0006E2  BE0100     MOV.D W0, W2
0006E4  B82061     MUL.UU W4, #1, W0
0006E6  710100     IOR W2, W0, W2
0006E8  718181     IOR W3, W1, W3
0006EA  510FE0     SUB W2, #0x0, [W15]
0006EC  598FE0     SUBB W3, #0x0, [W15]
0006EE  3A000B     BRA NZ, 0x706
165:                   {
166:                       if(ui32Number==2)
0006F0  90014E     MOV [W14+8], W2
0006F2  9001DE     MOV [W14+10], W3
0006F4  200020     MOV #0x2, W0
0006F6  200001     MOV #0x0, W1
0006F8  510F80     SUB W2, W0, [W15]
0006FA  598F81     SUBB W3, W1, [W15]
0006FC  3A0002     BRA NZ, 0x702
167:                       {
168:                           return 1;
0006FE  B3C010     MOV.B #0x1, W0
000700  370024     BRA 0x74A
169:                       }
170:                       else
171:                       {
172:                           return 0;
000702  EB4000     CLR.B W0
000704  370022     BRA 0x74A
173:                       }
174:                   }
175:                   uint32_t ui32Divider;
176:                   uint32_t ui32SqrtNumber =((uint32_t) sqrt((long double)(ui32Number)))+1;
000706  90004E     MOV [W14+8], W0
000708  9000DE     MOV [W14+10], W1
00070A  07FE15     RCALL ___floatunsidf
00070C  07FE60     RCALL ___truncdfsf2
00070E  07FE2A     RCALL _sqrtf
000710  07FDF7     RCALL ___fixunssfsi
000712  400061     ADD W0, #0x1, W0
000714  4880E0     ADDC W1, #0x0, W1
000716  980720     MOV W0, [W14+4]
000718  980731     MOV W1, [W14+6]
177:               
178:                   for(ui32Divider=3; ui32Divider<ui32SqrtNumber; ui32Divider+=2)
00071A  200030     MOV #0x3, W0
00071C  200001     MOV #0x0, W1
00071E  BE8F00     MOV.D W0, [W14]
000720  37000D     BRA 0x73C
000734  200022     MOV #0x2, W2
000736  200003     MOV #0x0, W3
000738  410F1E     ADD W2, [W14], [W14]
00073A  49975E     ADDC W3, [++W14], [W14--]
00073C  90002E     MOV [W14+4], W0
00073E  9000BE     MOV [W14+6], W1
000740  BE011E     MOV.D [W14], W2
000742  510F80     SUB W2, W0, [W15]
000744  598F81     SUBB W3, W1, [W15]
000746  39FFED     BRA NC, 0x722
179:                   {
180:                       if((ui32Number%ui32Divider) == 0) //check if ui32Divider is a in whole divider of ui32Number
000722  90004E     MOV [W14+8], W0
000724  9000DE     MOV [W14+10], W1
000726  BE011E     MOV.D [W14], W2
000728  07FE7D     RCALL ___umodsi3
00072A  500FE0     SUB W0, #0x0, [W15]
00072C  588FE0     SUBB W1, #0x0, [W15]
00072E  3A0002     BRA NZ, 0x734
181:                       {
182:                           return 0; //uiNumber32 isn't a prime number
000730  EB4000     CLR.B W0
000732  37000B     BRA 0x74A
183:                       }
184:                   }
185:                   return 1; //ui32Number is a Prime Number
000748  B3C010     MOV.B #0x1, W0
186:               }
00074A  FA8000     ULNK
00074C  060000     RETURN
